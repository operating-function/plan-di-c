This directory holds files that contain assembler and other code that is 
specific to particular platforms and processor architectures.  In general 
the type of the file is set by its extension and its specific function 
is set by its name in a way that is described here.

1. Usage
========

The aim is to have generic C code replaced as necessary with architecture
specific alternatives including assembler code.  To achieve this each
distinct function in the primary C source code files in the BSDNT root 
directory is guarded by defines of the form:

  HAVE_ARCH_<bsdnt_function>

that exclude the function from compilation when the symbol in question is 
defined. Hence, for example, the existence of the define:

  HAVE_ARCH_nn_add_mc

means that the C function nn_add_mc (which is defined in nn_linear.c) is to
be overridden by one defined in the arch directory. It may be overridden
by a platform specific version of the function, or perhaps an inline 
assembly version or even a standalone assembly version.
 
To achieve this exclusion, the generic C file <bsd_function_category>.c 
#include's a file <bsd_function_category>_arch.h, in the BSDNT top level 
directory, which is autogenerated at build time. It is the responsibility
of the <bsd_function_category>_arch.h file to ensure that the relevant
defines are included for the given architecture. 

Hence, for example, the file implementing the linear arithmetic functions:

  nn_linear.c 

will expect to find the file:

  nn_linear_arch.h

in the root directory.  

It is the responsibility of the build system for the architecture in question 
to create or copy such a file into this location before the build is started.

On *nix, configure does this automatically, and no build system modifications
are required to deal with new files when they are added.

2. Inline Assembly
==================

On *nix, the arch/inline directory holds files of the form:

   <bsdnt_function_category>_<platform>.h
   <bsdnt_function_category>_<platform>_<cpu>.h

The function categories are, for example,

  nn_linear     basic multiple length code with linear timing
  nn_quadratic  basic multiple length code with quadratic timing

The .h files contain the necessary guards and inline assembly for the 
specified platform, or platform and cpu, respectively.

Both the platform and cpu are automatically detected by configure and
the arch/inline directory is searched for files that match that data. 

Configure then automatically generates the files:

   <bsdnt_function_category>_arch.h

at the top level directory, filling it with defines of the form:

#include "arch/inline/<bsdnt_function_category>_<platform>_<cpu>.h"
#include "arch/inline/<bsdnt_function_category>_<platform>.h"

As this is all automatic, all the developer need do to add inline
assembly is to put the relevant .h file, correctly named for the
intended platform and/or cpu, in the arch/inline directory, and make
sure it contains the necessary override defines for the functions
provided, as discussed at the beginning of this document. No build
system modifications are necessary.

For example, to override nn_add_mc in nn_linear.c on x86_64 on a 
core2 cpu, simply place the file containing the relevant inline
assembly into arch/inline/nn_linear_x86_64_core2.h and ensure it
contains the line:

   #define HAVE_ARCH_nn_add_mc

When configure is run again, this file will be automatically included
in the build, overriding the generic C version of the function nn_add_mc
as defined in nn_linear.c.

At this point the platforms that are recognised are:

   x86     x86 architecture with 32 bit OS kernel
   x86_64  x86 architecture with 64 bit OS kernel

The cpu's recognised to date are:

   k10      AMD K10 (Phenom, Phenom II, etc)
   k8       AMD K8
   atom     Intel Atom
   core2    Intel Core 2 Duo
   nehalem  Intel i3/5/7 nehalem core
   p4       Intel Pentium 4

It is possible to use inline assembly code written for more than one 
processor in a single build. For example, it is possible to use k8 and k10
code with the latter overriding the former where there are separate 
versions of the same function. This is done by changing the list of EXTS as 
recorded in the configure file. 

For example, configure contains the lines:

        k10)
            EXTS="_k10 _k8";;

This means that when the build machine is an AMD K10, inline assembly code
written for the k10 is selected first and overrides everything else. But if
there is k8 code for functions not yet overridden, it will also be used.
Finally any code in the generic file:

   arch/inline/<bsdnt_function_category>_x86_64.h

may provide routines that are generic to all x86_64 machines. Anything that
remains to be defined is picked up from the primary/generic C file, 
<bsdnt_function_category>.c in the top level directory.

Again, configure manages the build of the relevant files automatically. All
that is required is to provide the correctly named files and ensure they 
contain the relevant override defines for functions they provide.

The developer is not required to provide any specific file. If configure 
doesn't find an architecture specific file for a given plaform or cpu it does 
not raise an error. Thus only files which actually contain code need exist for
a given architecture.
